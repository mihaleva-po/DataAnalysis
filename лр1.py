# -*- coding: utf-8 -*-
"""lr1new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1avxDtzDjkIL-sibf-MsRI-q5UtMK6MA1

Импорт нужных библиотек
"""

import pandas as pd
import io

"""Загрузка данных в тетрадь"""

from google.colab import files
uploaded = files.upload()
dataset = pd.read_csv(io.BytesIO(uploaded['лр1.csv']), delimiter = "	")

df = pd.DataFrame(dataset)

"""Вывод первых 20 строк с помощью head"""

print(df.head(20))

"""Описание колонок:
1.	**total_images**: Количество фотографий квартиры в объявлении. Столбец имеет целочисленный тип данных.
2.	**last_price**: Цена на момент снятия с публикации. Столбец имеет числовой тип данных.
3.	**total_area**: Площадь квартиры в квадратных метрах. Столбец имеет числовой тип данных.
4.	**first_day_exposition**: Дата публикации. Столбец имеет временной тип данных.
5.	**rooms**: Количество комнат. Столбец имеет целочисленный тип данных.
6.	**ceiling_height**: Высота потолков. Столбец имеет числовой тип данных.
7.	**floors_total**: Количество этажей в доме. Столбец имеет целочисленный тип данных.
8.	**living_area**: Жилая площадь в квадратных метрах. Столбец имеет числовой тип данных.
9.	**floor**: Количество этажей. Столбец имеет целочисленный тип данных.
10.	 **is_apartment**: Апартаменты. Столбец имеет булевый тип данных.
11.	 **studio**: Квартира-студия. Столбец имеет булевый тип данных.
12.	 **open_plan**: Свободная планировка. Столбец имеет булевый тип данных.
13.	 **kitchen_area**: Площадь кухни в квадратных метрах. Столбец имеет числовой тип данных.
14.	 **balcony**: Количество балконов. Столбец имеет целочисленный тип данных.
15.	**locality_name**: Название населенного пункта. Столбец имеет текстовый тип данных.
16.	 **airports_nearest**: Расстояние до ближайшего аэропорта в метрах. Столбец имеет числовой тип данных.
17.	 **cityCenters_nearest**: Расстояние до центра города. Столбец имеет числовой тип данных.
18.	 **parks_around3000**: Количество парков в радиусе 3 км. Столбец имеет целочисленный тип данных.
19.	 **parks_nearest**: Расстояние до ближайшего парка. Столбец имеет числовой тип данных.
20.	 **ponds_around3000**: Количество водоемов в радиусе 3 км. Столбец имеет целочисленный тип данных.
21.	 **ponds_nearest**: Расстояние до ближайшего водоема. Столбец имеет числовой тип данных.
22.	 **days_exposition**: Количество дней размещения объявления на сайте. Столбец имеет целочисленный тип данных.

С помощью метода .info оценим данные
"""

df.info()

"""Видно, что названия столбцов правильны, а именно не имеют лишние символы, пробелы или точки с запятой. Количество заполненных ячеек в столбцах различно, значит часть данных не заполнена. Столбцы "день публикации", "количество этажей", "апартаменты", "количество балконов", "количество водоемов", "количество парков" имеют неверный тип данных.

Выведем на экран названия столбцов
"""

df.columns

"""Названия столбцов корректны, т.е не содержат пробелы и имеют понятные названия

Проверим данные на наличие явных дубликатов
"""

print(df.duplicated().sum())

"""Найдено 0 дубликатов

Посмотрим количество пропусков в столбцах
"""

print(df.isna().sum())

"""В данных много пропусков

Проверяем корректность данных всех столбцов
"""

print(df['total_images'].unique())

"""В первом столбце все значения корректны"""

print(df['last_price'].describe())

"""Данные корректны"""

print(df['total_area'].describe())

"""Данные корректны"""

print(df['first_day_exposition'].unique().tolist())

"""Данные представлены в формате datetime. Время всегда 00:00:00, от него можно избавиться. Преобразуем данные."""

df['first_day_exposition'] = pd.to_datetime(df['first_day_exposition'], format='%Y-%m-%d' )
print(df['first_day_exposition'].head(10))

print(df['rooms'].unique())

"""Данные корректны и предствлены в правильном типе."""

print(df['ceiling_height'].describe())

"""Посчитаем среднее значение по столбцу ceiling_height"""

mean_value = df['ceiling_height'].mean()

"""Чтобы не лишиться строк с важными данными, заполним значения NaN средним значением по столбцу"""

df['ceiling_height'] = df['ceiling_height'].fillna(mean_value)
print(df['ceiling_height'].unique().tolist())

print(df['floors_total'].unique().tolist())

"""Посчитаем среднее значение по столбцу floors_total"""

mean_value = df['floors_total'].mean()

"""Заменим пропуски на среднее значение по столбцу и преобразуем данные к целочисленному виду."""

df['floors_total'] = df['floors_total'].fillna(mean_value)
df['floors_total'] = df['floors_total'].astype(int)
print(df['floors_total'].unique().tolist())

print(df['living_area'].unique().tolist())

"""Посчитаем среднее значение по столбцу living_area"""

mean_value = df['living_area'].mean()

"""Чтобы не лишиться строк с важными данными, заполним значения NaN средним значением по столбцу"""

df['living_area'] = df['living_area'].fillna(mean_value)
print(df['living_area'].unique().tolist())

print(df['floor'].unique().tolist())

"""Данные имеют правильный тип, пропуски отсутствуют"""

print(df['is_apartment'].unique())

"""Преобразуем данные столбца к булевому типу и заменим nan на пробел"""

df['is_apartment'] = df['is_apartment'].astype('bool')
df['is_apartment'] = df['is_apartment'].fillna('')
print(df['is_apartment'].unique())

"""Столбцы studio и open_plan имеют корректные данные"""

print(df['studio'].unique().tolist())

print(df['open_plan'].unique().tolist())

print(df['kitchen_area'].unique().tolist())

"""Посчитаем среднее значение по столбцу kitchen_area"""

mean_value = df['kitchen_area'].mean()

"""Заменим пустые значения на среднее значение по столбцу"""

df['kitchen_area'] = df['kitchen_area'].fillna(mean_value)
print(df['kitchen_area'].unique().tolist())

print(df['balcony'].unique().tolist())

"""Если количество балконов отсутствует, значит их нет. Заменим nan на 0. И преобразуем данные к типу int."""

df['balcony'] = df['balcony'].fillna(0)
df['balcony'] = df['balcony'].astype('int')
print(df['balcony'].unique().tolist())

print(df['locality_name'].unique())

"""Здесь много аналогичных названий населенных пунктов. Проведем замену названий.

Преобразуем данные в строку и избавимся от одинаковых названий и с помощью метода replace заменим похожие слова в строке.
"""

stroka = str(df['locality_name'].tolist())
stroka = stroka.replace('[', '')
stroka = stroka.replace(']', '')
stroka = stroka.replace("'", '')
stroka = stroka.replace('посёлок', 'поселок')
stroka = stroka.replace('деревня Кудрово', 'Кудрово')
stroka = stroka.replace('деревня', 'поселок')
stroka = stroka.replace('станции ', '')
stroka = stroka.replace('коттеджный ', '')
stroka = stroka.replace('городского типа ', '')
stroka = stroka.replace('городской ', '')
stroka = stroka.replace('поселок Любань', 'Любань')
stroka = stroka.replace('поселок Мурино', 'Мурино')
stroka = stroka.replace('Никольское', 'село Никольское')
stroka = stroka.replace('село Павлово', 'поселок Павлово')
stroka = stroka.replace('садовое товарищество', 'поселок')

"""Превратим данные в лист с разделителем ","."""

mas = stroka.split(', ')

"""Запишем данные обратно в стобец locality_name"""

k = len(df['locality_name'])
for i in range(k):
    df['locality_name'][i] = mas[i]

"""Проверим содержание столбца"""

print(df['locality_name'].unique())

"""Похожие данные успешно заменены."""

print(df['airports_nearest'].unique().tolist())

"""Если расстояние до аэропорта не написано, считаем, что в данном городе аэропорт отсутствует. Заменим nan на прочерк."""

df['airports_nearest'] = df['airports_nearest'].fillna("-")
print(df['airports_nearest'].unique().tolist())

print(df['cityCenters_nearest'].unique().tolist())

"""При отсутствии расстояния до центра города, квартира находится в центре города, следовательно расстояние равняется нулю. Заменим nan на 0."""

df['cityCenters_nearest'] = df['cityCenters_nearest'].fillna(0)
print(df['cityCenters_nearest'].unique().tolist())

print(df['parks_around3000'].unique())

"""Если количество парков отсутствует, то их нет поблизости. Заменим nan на 0. Преобразуем количество парков к целочисленному типу."""

df['parks_around3000'] = df['parks_around3000'].fillna(0)
df['parks_around3000'] = df['parks_around3000'].astype('int')
print(df['parks_around3000'].unique())

print(df['parks_nearest'].unique().tolist())

"""Если расстояние до парка отсутствует, то его нет поблизости. Заменим nan на прочерк."""

df['parks_nearest'] = df['parks_nearest'].fillna("-")
print(df['parks_nearest'].unique().tolist())

print(df['ponds_around3000'].unique().tolist())

"""Если количество водоемов отсутствует, то их нет поблизости. Заменим nan на 0. Преобразуем количество водоемов к целочисленному типу."""

df['ponds_around3000'] = df['ponds_around3000'].fillna(0)
df['ponds_around3000'] = df['ponds_around3000'].astype('int')
print(df['ponds_around3000'].unique().tolist())

print(df['ponds_nearest'].unique().tolist())

"""Если расстояние до водоемов отсутствует, то их нет поблизости. Заменим nan на прочерк."""

df['ponds_nearest'] = df['ponds_nearest'].fillna("-")
print(df['ponds_nearest'].unique().tolist())

print(df['days_exposition'].unique().tolist())

"""Если данные о количестве дней размещения объявления отсутствуют, то будем считать, что с момента размещения объявления прошло меньше суток. Заменим пустые значения на 0 и преобразуем данные к int."""

df['days_exposition'] = df['days_exposition'].fillna(0)
df['days_exposition'] = df['days_exposition'].astype(int)
print(df['days_exposition'].unique().tolist())

"""Проверим все ли типы данных соответствуют действительности"""

df.dtypes

"""Все типы данных столбцов соответствуют действительности.

Посмотрим пропуски
"""

print(df.isna().sum())

"""Пропуски отсутствуют, следовательно все пустые значения были преобразованы.

Создана сводная таблица "Количество апартаментов по населенным пунктам" с сортировкой по убыванию
"""

(df.pivot_table(index='locality_name', values='is_apartment',
               aggfunc='count', fill_value=0, margins=True) 
   .sort_values('is_apartment', ascending = False) )

"""Данная таблица показывает количество апартаментов по населенным пунктам. Наибольшее количество апартаментов сдается в Санкт-Петербурге.

Создана группировка, показывающая среднее количество комнат по городам
"""

test = pd.pivot_table(df, index='locality_name', values='rooms',aggfunc='mean',
                      fill_value = 0).reindex().sort_values(by='rooms',
                                                            ascending=False)
display(test)

"""Создана группировка "Самая высокая цена по населенным пунктам" с сортировкой по убыванию."""

test = pd.pivot_table(df, index='locality_name', values='last_price', aggfunc='max',
                      fill_value = 0).reindex().sort_values(by='last_price',
                                                            ascending=False)
display(test)

"""По этой группировке делаем вывод, что самая дорогая недвижимость в Санкт-Петербурге.

Создана сводная таблица "Минимальные цены по этажу" с сортировкой по возрастанию
"""

test = pd.pivot_table(df, index='floor', values='last_price', aggfunc='min',
                      fill_value = "-").reindex().sort_values(by='last_price',
                                                            ascending=True)
display(test)

"""Как видно из группировки, самый недорогой этаж -- 25

# Вывод
Данные представляют набор сведений о продающейся недвижимости, которая имеет общую (**total_area**) и жилую площадь (**living_area**), цену (**last_price**), количество комнат (**rooms**), этаж(**floor**), количество этажей в доме(**total_floor**) и расположена в конкретном населенном пункте (**locality_name**). Также есть информация о количестве расположеннных рядом водоемов (**ponds_around3000**) и парков (**parks_around3000**) и расстоянии до них (**ponds_nearest** и **parks_nearest**); расстоянии до центра города (**cityCenters_nearest**) и до аэропорта (**airports_nearest**). Также есть разные виды жилья: студии (**studio**) и апартаменты (**is_apartment**). 
Была осуществлена предварительная обработка данных csv-файла, были выявлены и устранены проблемы в этих данных. В данных были устранены пропуски – заменены на среднее значение, прочерк или нуль. Были устранены явные и неявные дубликаты в записях. По отредактированным данным были построены сводные таблицы и группировки. По ним можно сделать вывод, наибольшее количество апартаментов сдается в Санкт-Петербурге. Санкт-Петербург лидирует в самых дорогих ценах за недвижимость. Минимальная цена за квартиру найдена на 25 этаже.
"""