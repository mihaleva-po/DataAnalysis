# -*- coding: utf-8 -*-
"""lr2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19c6Bz2CApaiGe759o7OM7yJH8NlyjNOr

Импорт нужных библиотек
"""

import pandas as pd
import io
import numpy as np

"""Загрузка данных в тетрадь"""

from google.colab import files
uploaded = files.upload()
dataset = pd.read_csv(io.BytesIO(uploaded['lr2.csv']), delimiter = ",")
df = pd.DataFrame(dataset)

"""Дан файл, содержащий сведения о заемщиках. Описание колонок:
1.	children: количество детей в семье
2.	daysEmployed: общий трудовой стаж в днях
3.	dob_years: возраст клиента в годах
4.	education: уровень образования клиента
5.	education_id: идентификатор уровня образования
6.	family_status: семейное положение
7.	family_status_id: идентификатор семейного положения
8.	gender: пол клиента
9.	income_type: тип занятости
10.	debt: имел ли задолженность по возврату кредитов
11.	total_income: ежемесячный доход
12.	purpose: цель получения кредита

Выведем первые 5 строк для оценки данных.
"""

df.head(5)

"""Посмотрим названия столбцов, типы данных и пропуски"""

df.info()

"""Столбцы имеют правильные названия. daysEmployed, dept имеют некорректные типы данных. Пропуски присутствуют в двух столбцах (daysEmployed и total_income).

Проверим данные на наличие явных дубликатов
"""

print(df.duplicated().sum())

"""Найдены дубликаты, избавимся от них. Обновим индексацию: чтобы в ней не осталось пропусков"""

df = df.drop_duplicates().reset_index()

"""Проверим корректность значений всех столбцов

Посмотрим числовые характеристики столбца children
"""

df['children'].describe()

"""Минимальное значение в этом стобце -1, отрицательные значения некорректны, т.к. данные характеризуют количество детей.

Добавим библиотеку warnings, чтобы убрать вылезающие предупреждения
"""

import warnings
warnings.filterwarnings("ignore")

"""Если число отрицательное, будем считать минус опечаткой со стороны заемщика. Заменим все отрицательные числа на модуль этих чисел."""

for i in range(len(df['children'])):
  if df['children'][i] < 0:
    df['children'][i] = abs(df['children'][i])

"""Проверим изменения"""

df['children'].describe()

"""Теперь минимальное значение 0.

Проверяем следующий столбец
"""

df['daysEmployed'].describe()

"""Опять минимальное число -- отрицательное, поступаем как с предыдущим столбцом."""

for i in range(len(df['daysEmployed'])):
  if df['daysEmployed'][i] < 0:
    df['daysEmployed'][i] = abs(df['daysEmployed'][i])

"""Столбец имеет пропуски. Если количество дней стажа не заполнено, заменим его на среднее значение."""

days_mean = df['daysEmployed'].mean()

df['daysEmployed'] = df['daysEmployed'].fillna(days_mean)

"""Столбец хранит данные о количестве дней трудового стажа. Преобразуем данные к целочисленному типу."""

df['daysEmployed'] = df['daysEmployed'].astype('int')

"""Проверим столбец dob_years"""

df['dob_years'].describe()

"""Человек с возрастом 0 не может брать кредиты. Посмотрим сколько данных с таким значением"""

count = 0 # Количество ячеек со значением 0
for i in range(len(df['dob_years'])):
  if df.iloc[i]['dob_years'] == 0:
    count +=1
print(count)

"""Данных со значением возраста "0" 101 значение. Заменим нули на среднее значение по столбцу."""

mean_value = int(df['dob_years'].mean())
df['dob_years'] = df['dob_years'].replace(0, mean_value)

"""Посмотрим уникальные значения столбца education"""

print(df['education'].unique())

"""Приведем все значения к нижнему регистру"""

df['education'] = df['education'].str.lower()

"""Проверим уникальность исправленных данных"""

print(df['education'].unique())

"""Все значения имеют уникальный смысл

Посмотри числовые характеристики столбца education_id
"""

df['education_id'].describe()

"""Пропуски отсутствуют, тип данных корректный, отрицательные числа отсутствуют.

Проверим уникальность значений столбца family_status
"""

print(df['family_status'].unique())

"""Все значения уникальны. Пропуски отсутствуют.

Проверим числовые характеристики столбца family_status_id
"""

df['family_status_id'].describe()

"""Пропуски отсутствуют, тип данных корректный, отрицательные числа не найдены.

Проверим уникальность значений столбца gender
"""

print(df['gender'].unique())

"""В России всего два пола. Значение 'XNA' в столбце одно, избавимся от него.
Сначала заменим XNA на nan. Затем удалим строки, содержащие пустые значения.

"""

for i in range(len(df['gender'])):
  if df['gender'][i] == 'XNA':
    df['gender'][i] = np.nan
df = df.dropna(subset=['gender'])

"""В столбце Гендер произведем изменения для удобства построения диаграмм, заменим мужской пол на 1, а женский на 0."""

df['gender'] = df['gender'].replace('M', 1)
df['gender'] = df['gender'].replace('F', 0)

"""Проверим уникальность значений столбца income_type"""

print(df['income_type'].unique())

"""Все значения имеют уникальный смысл

Проверим уникальность значений столбца debt
"""

print(df['debt'].unique())

"""Столбец наличие задолженностей должен иметь булевый тип, но для создания диаграмм оставим так. 0 - отсутствие задолженности, 1 - есть задолженность.

Проверим числовые характеристики столбца total_income
"""

df['total_income'].describe()

"""Из оценки данных (.info) наблюдаем наличие пустых значений. Заменим их на среднее значение."""

income_mean = df['total_income'].mean()

df['total_income'] = df['total_income'].fillna(income_mean)

"""Преобразуем данные в тип int"""

df['total_income'] = df['total_income'].astype('int')

"""Проверим уникальность данных столбца purpose"""

print(df['purpose'].unique())

"""Заменим альтернативные значения"""

df['purpose'] = df['purpose'].replace(['операции со своей недвижимостью', 'покупка коммерческой недвижимости', 'покупка недвижимости', 'недвижимость',
                                       'операции с коммерческой недвижимостью', 'операции с жильем'], 'операции с недвижимостью')
df['purpose'] = df['purpose'].replace(['строительство собственной недвижимости', 'строительство жилой недвижимости','строительство недвижимости',], 'строительство')
df['purpose'] = df['purpose'].replace(['жилье', 'покупка жилья для сдачи', 'покупка жилья для семьи', 'покупка жилой недвижимости', 'покупка жилья', 'покупка своего жилья'], 'покупка жилья')
df['purpose'] = df['purpose'].replace(['на покупку автомобиля', 'автомобили', 'на покупку своего автомобиля', 'автомобиль', 'сделка с подержанным автомобилем', 
                                       'покупка автомобиля', 'сделка с автомобилем', 'свой автомобиль', 'на покупку подержанного автомобиля'], 'приобретение автомобиля')
df['purpose'] = df['purpose'].replace(['на проведение свадьбы', 'сыграть свадьбу'], 'свадьба')
df['purpose'] = df['purpose'].replace('ремонт жилью', 'ремонт жилья')
df['purpose'] = df['purpose'].replace(['профильное образование', 'заняться образованием', 'дополнительное образование', 'заняться высшим образованием', 
                                       'высшее образование', 'получение дополнительного образования', 'образование', 'получение высшего образования'], 'получение образования')

"""Посмотрим результат замены"""

print(df['purpose'].unique())

"""Смысл значений не повторяется

Проверим типы данных
"""

df.dtypes

"""Все типы данных корректны

# Матрицы диаграмм рассеяния

Посмотрим столбцы
"""

df.columns

"""Удалим столбец Индекс"""

df.pop('index')

"""Запишем данные столбцов в переменные"""

gender = df['gender']
id_edu = df['education_id']
days = df['daysEmployed']
income = df['total_income']
debt = df['debt']
child = df['children']
age = df['dob_years']
id_fam = df['family_status_id']

"""Создадим DataFrame с данными столбцов"""

df_graf1 = pd.DataFrame({'education_id':id_edu,'daysEmployed':days, 'total_income':income,})
df_graf2 = pd.DataFrame({'gender':gender,'children':child,'family_status_id':id_fam})
df_graf3 = pd.DataFrame({'gender':gender,'dob_years':age, 'debt':debt})

"""Построим точечные диаграммы

В наборе данных для каждого человека известны следующие данные: образование (0 - высшее, 1 - среднее, 2 - неоконченное высшее, 3 - начальное, 4 - ученая степень), трудовой стаж в днях и ежемесячных доход.
Построим матрицу рассеяния:
"""

pd.plotting.scatter_matrix(df_graf1, figsize= (9, 9))
warnings.filterwarnings("ignore")

"""По визуализации данных можно сделать следующие выводы:
1. Чем лучше образование (меньше id_education), тем больше доход. 
2. Количество дней стажа не зависит от уровня образования.
3. Доход не зависит от стажа
4. Больше всего в выборке встречаются люди со средним образованием, с ученой степенью очень мало
5. В основном трудовой стаж составляет от 0 до 5000 дней
6. Доход составляет от 0 до 0,25

В наборе данных для каждого человека известны следующие данные: пол (0 - женский, 1 - мужской), количество детей и индификатор семейного положения (0 - женат / замужем, 1 - гражданский брак, 2 - вдовец / вдова, 3 - в разводе, 4 - не женат / не замужем).
Построим матрицу рассеяния:
"""

pd.plotting.scatter_matrix(df_graf2, figsize= (9, 9))
warnings.filterwarnings("ignore")

"""По визуализации данных можно сделать следующие выводы:

1. Семейный статус не зависит от гендера.
2. Количество детей от 0 до 5 ли 20, другие значения отсутствуют.
3. Больше всего в выборке встречаются люди с семейным положением женат/замужем.
4. Количество детей не зависит от гендера.
5. В выборке больше женщин, чем мужчин.
6. Количество детей не зависит от семейного статуса.

В наборе данных для каждого человека известены следующие данные: пол (0 - женский, 1 - мужской), возраст и задолженность (0 - отсутствие задолженности, 1 - есть задолженность.). Построим матрицу рассеяния:
"""

pd.plotting.scatter_matrix(df_graf3, figsize= (9, 9))
warnings.filterwarnings("ignore")

"""По визуализации данных можно сделать следующие выводы:
1. Задолженность не зависит от гендера.
2. В выборке женщин больше, чем мужчин.
3. Возраст людей от 18 до 80 лет
4. Чаще всего встречаются люди в возрасте 30-40 лет.
5. У большинства людей отсутствует задолженность.

# Коэффициент корреляции Пирсона

Найдем коэффициенты Пирсона.
"""

df.corr()

"""**Высокая положительная** связь между столбцами dob_years и daysEmployed.

**Слабая положительная связь:**
1. children со столбцами gender, debt, total_income.
2. daysEmployed со столбцами education_id, family_status_id.
3. dob_years со столбцами education_id.
4. education_id со столбцами family_status_id, gender, debt.
5. family_status_id со столбцами debt.
6. gender со столбцами debt, total_income.

**Слабая отрицательная связь:**  
1. children со столбцами daysEmployed, dob_years, education_id, family_status_id.
2. daysEmployed со столбцами gender, debt, total_income.
3. dob_years со столбцами family_status_id, gender, debt, total_income.
4. family_status_id со столбцами gender, total_income.
5. total_income со столбцами education_id, debt.

Средняя положительная связь отсутствует.
Средняя отрицательная связь отсутствует.
Высокая отрицательная связь отсутствует.
Очень высокая отрицательная связь отсутствует.

**Вывод:** В основном между объектами БД отсутствует линейная связь, есть только одна сильная связь (dob_years и daysEmployed).

# Ковариация

Найдем ковариационную матрицу
"""

df.cov()

"""**Положительная связь между столбцами:**
1. children со столбцом total_income
2. daysEmployed со столбцами dob_years, education_id, family_status_id
3. dob_years со столбцом education_id
4. gender со столбцом total_income

**Отрицательная связь между столбцами:**
1. children со столбцами daysEmployed, dob_years, family_status_id
2. daysEmployed со столбцами gender, debt, total_income
3. dob_years со столбцами family_status_id, total_income
4. education_id со столбцом total_income
5. family_status_id со столбцом total_income
6. debt со столбцом total_income

**Независимые друг от друга столбцы:**
1. children со столбцами education_id, gender, debt
2. education_id со столбцами family_status_id, gender, debt
3. family_status_id со столбцами gender, debt
4. debt со столбцом gender

# Тепловая карта корреляции

Импорт библиотек
"""

import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt

"""Строим heatmap"""

sns.heatmap(df.corr(), annot = True, vmin = -1, vmax = 1, cmap = 'jet', linewidths = 1, linecolor = 'black')
warnings.filterwarnings("ignore")

"""Банк собирает данные о своих клиентах и хочет выяснить, сколько заемщиков не смогут выполнить свои обязательства. Целевым признаком является столбец наличие задолженности по возврату кредитов.

**Вывод:** Данные представляют набор сведений о заемщиках с указанием их пола (gender), возраста (dob_years), количества детей (children), стажа в днях (daysEmployed), уровня образования (education) и его id (education_id), семейное положение (family_status) и его id (family_status_id), занимаемой должности (income_type), наличия задолжностей (debt), ежемесячного дохода (total_income) и цели получения кредита (purpose).

Была осуществлена предварительная обработка данных csv-файла, а именно: были осуществлены проверки на наличие пропусков и дубликатов, были изменены некорректные типы данных. По отредактированным данным были построены графики. Были исследованы связи между признаками набора данных.

В результате работы были сделаны следующие выводы: 
1. Чем лучше образование, тем больше доход.
2. Больше всего в выборке встречаются люди со средним образованием.
3. В основном трудовой стаж составляет от 1 до 5000 дней
4. В выборке женщин больше, чем мужчин.
5. Возраст людей в выборке от 18 до 80 лет
6. Чаще всего встречаются люди в возрасте 30-40 лет.
7. У большинства людей отсутствует задолженность.
8. Количество детей от 0 до 5.
9. Больше всего в выборке встречаются люди с семейным положением женат/замужем.

# Диаграмма размаха

Построим график типа boxplot для столбца Возраст
"""

sns.boxplot(df['dob_years'])
warnings.filterwarnings("ignore")

"""Как видно из графика, минимальное возраст - 20, максимальный - 80, медиана - 43, верхний квартиль - 53, нижний квартиль - 33, выбросы данных отсутствуют. В основном возраст клиентов приходится на интервал от 33 до 53.

# Гистограмма

Всего 5 статусов семейного положения. Посчитаем по каждому средний доход.

Для начала создадим массивы со значениями дохода по каждому статусу
"""

id_0 = [] # Массив доходов по статусу 0, т.е. женат / замужем
id_1 = []
id_2 = []
id_3 = []
id_4 = []

for i in range(len(df['family_status_id'])):
  if df.iloc[i]['family_status'] == 'женат / замужем':
    id_0.append(df.iloc[i]['total_income'])
  if df.iloc[i]['family_status'] == 'гражданский брак':
    id_1.append(df.iloc[i]['total_income'])
  if df.iloc[i]['family_status'] == 'вдовец / вдова':
    id_2.append(df.iloc[i]['total_income'])
  if df.iloc[i]['family_status'] == 'в разводе':
    id_3.append(df.iloc[i]['total_income'])  
  if df.iloc[i]['family_status'] == 'Не женат / не замужем':
    id_4.append(df.iloc[i]['total_income'])

"""Импортируем библиотеку для вычисления среднего значения"""

from statistics import mean

"""Строим гистограмму"""

# Массив со средними значениями по семейному статусу
y = [mean(id_0), mean(id_1), mean(id_2), mean(id_3), mean(id_4)]
# Массив с ID по семейным статусам
x = df['family_status'].unique().tolist()
fig, ax = plt.subplots(figsize=(10, 5))
ax.bar(x, y)
plt.xlabel("Cемейный статус")
plt.ylabel("Средний доход")
plt.show()
warnings.filterwarnings("ignore")

"""Из гистограммы видно, что самый низкий средний доход у вдовцов."""